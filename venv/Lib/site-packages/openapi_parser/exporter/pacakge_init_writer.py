from datetime import datetime
from typing import *

from functional import Option

import openapi_parser
from openapi_parser.parser import OpenApiParser
from openapi_parser.util.utils import StrIO
from .abstract_writer import Writer, yielder, writer
from .description_writer import DescriptionWriter
from .footer_writer import FooterWriter
from .header_writer import HeaderWriter

class PackageInitWriter(HeaderWriter, FooterWriter, DescriptionWriter, Writer):
    
    @property
    def submodules(self) -> Iterator[str]:
        yield 'client'
    
    @property
    def from_imports(self) -> Iterator[str]:
        for m in self.submodules:
            yield f'.{m}.*'
    
    def dump_package_description(self, parser: OpenApiParser) -> Iterator[str]:
        def _gen(compact: bool):
            yield parser.metadata.id
            yield
            yield from self.text_block(parser.metadata.info.description)
            
            if (parser.metadata.external_docs is not None):
                yield " - External Documentation:"
                with self.indent():
                    yield parser.metadata.external_docs.url
                    yield from self.text_block(parser.metadata.external_docs.description)
            
            if (parser.metadata.info.licence is not None):
                yield f" - License: {parser.metadata.info.licence.name}"
                with self.indent():
                    yield from Option(parser.metadata.info.licence.url).map('({})'.format)
            
            if (parser.metadata.info.contact is not None):
                yield " - Contacts:"
                with self.indent():
                    yield from Option(parser.metadata.info.contact.name).map(' - Name: {}'.format)
                    yield from Option(parser.metadata.info.contact.url).map(' - URL: {}'.format)
                    yield from Option(parser.metadata.info.contact.email).map(' - Email: {}'.format)
                yield
            
            yield f"Generated by Python OpenAPI Parser v{openapi_parser.__version__}"
        
        return self.smart_description(description_gen=_gen)
    
    def dump_package_metadata(self, parser: OpenApiParser) -> Iterator[str]:
        yield "from collections import namedtuple"
        yield
        yield f"__title__ = {parser.name!r}"
        yield f"__author__ = '{openapi_parser.__title__}-{openapi_parser.__version__}'"
        yield f"__license__ = {Option(parser.metadata.info.licence).map(lambda l: l.name).get_or_else('Unlicensed')!r}"
        yield f"__copyright__ = 'Copyright {datetime.now().year} {parser.author}'"
        yield f"__version__ = {parser.metadata.info.version!r}"
        yield
        yield "VersionInfo = namedtuple('VersionInfo', 'major minor micro releaselevel serial')"
        yield "version_info = VersionInfo(*__version__.split('.'), releaselevel='alpha', serial=0)"
        
        self.export('version_info')
        self.export('__title__')
        self.export('__author__')
        self.export('__license__')
        self.export('__copyright__')
        self.export('__version__')
    
    def dump_package_exports(self, parser: OpenApiParser) -> Iterator[str]:
        yield '__pdoc__ = { }'
        yield '__pdoc_extras__ = [ ]'
        yield
        
        yield '_submodules = \\'
        yield '['
        with self.indent():
            for m in self.submodules:
                yield f'{m},'
        yield ']'
        yield
        
        yield "for _submodule in _submodules:"
        with self.indent():
            yield "_submodule_name = _submodule.__name__.partition(f'{__name__}.')[-1]"
            yield "__all__.extend(_submodule.__all__)"
            yield "__pdoc__[_submodule_name] = True"
            yield "_submodule.__pdoc__ = getattr(_submodule, '__pdoc__', dict())"
            yield "_extras = getattr(_submodule, '__pdoc_extras__', list())"
            yield "for _element in _submodule.__all__:"
            with self.indent():
                yield "__pdoc__[_element] = _element in _extras"
        yield
    
    def dump_package_init_file(self, parser: OpenApiParser) -> Iterator[str]:
        yield from self.dump_package_description(parser)
        yield from self.dump_headers()
        yield from self.dump_package_metadata(parser)
        yield from self.dump_footers(ordered=False)
        yield from self.dump_package_exports(parser)
    
    # region Writers
    @yielder
    def write_package_init_file(self, parser: OpenApiParser) -> Optional[Iterator[str]]:
        # noinspection PyTypeChecker
        return self.yield_package_init_file(parser)
    @yielder
    def yield_package_init_file(self, parser: OpenApiParser) -> Iterator[Tuple[int, str]]:
        # noinspection PyTypeChecker
        return self.dump_package_init_file(parser)
    
    @overload
    def write_package_init_file(self, parser: OpenApiParser) -> Iterator[str]:
        pass
    # noinspection PyOverloads
    @overload
    def write_package_init_file(self, parser: OpenApiParser, *, file: StrIO) -> None:
        pass
    @writer
    def write_package_init_file(self, parser: OpenApiParser) -> Optional[Iterator[str]]:
        # noinspection PyTypeChecker
        return self.yield_package_init_file(parser)
    # endregion
    