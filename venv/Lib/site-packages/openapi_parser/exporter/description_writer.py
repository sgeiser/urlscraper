import json
from abc import ABC
from typing import *

from openapi_parser.model import HavingPath, HavingExtendedDescription, HavingDescription
from .abstract_writer import Writer

class DescriptionWriter(Writer, ABC):
    MAX_DESCRIPTION_LINE_LENGTH: int = 95
    
    def multiline_text(self, text: Optional[str]) -> Iterator[str]:
        if (text is None):
            return
        
        words = iter(text.split())
        current_line = next(words)
        for word in words:
            if len(current_line) + 1 + len(word) > self.MAX_DESCRIPTION_LINE_LENGTH:
                yield current_line
                current_line = word
            else:
                current_line += ' ' + word
        else:
            yield current_line
    
    def iter_strip(self, text_iter: Iterator[str]) -> Iterator[str]:
        stored = False
        for line in text_iter:
            if (not line):
                stored = True
            else:
                if (stored):
                    stored = False
                    yield
                yield line
    
    def text_block(self, text: Optional[str], *, compact: bool = False) -> Iterator[str]:
        if (text is not None):
            for block in text.splitlines():
                if (not block):
                    continue
                yield from self.multiline_text(block)
                if (not compact):
                    yield
    
    # noinspection PyArgumentList
    def smart_description(self, description_gen: Callable[[], Iterator[str]], *, compact: bool = False) -> Iterator[str]:
        lines = '\n'.join(filter(None, description_gen(compact=True))).strip().splitlines()
        if (not lines):
            pass
        elif (len(lines) == 1):
            yield from self.inline_description(lines[0])
        else:
            yield from self.full_description(description_gen(compact=compact))
    
    def inline_description(self, description_text: str) -> Iterator[str]:
        yield self.TRIPLE_QUOT + ' ' + description_text.strip() + ' ' + self.TRIPLE_QUOT
        yield
    
    def full_description(self, description_iter: Iterator[str]) -> Iterator[str]:
        yield self.TRIPLE_QUOT
        yield from self.iter_strip(description_iter)
        yield self.TRIPLE_QUOT
        yield
    
    def generate_item_description(self, item: HavingDescription, extra_gen: Optional[Iterator[str]] = None, *, item_type: str, path_item: Optional[HavingPath] = None, compact: bool) -> Iterator[str]:
        if (path_item is None and isinstance(item, HavingPath)):
            path_item = item
        
        if (isinstance(item, HavingExtendedDescription)):
            yield from self.text_block(item.summary)
        yield from self.text_block(item.description)
        
        if (extra_gen is not None):
            yield from extra_gen
        
        if (isinstance(item, HavingExtendedDescription) and item.example is not None):
            example = item.example
            if (not isinstance(example, str)):
                example = json.dumps(example, indent=self.INDENT_SIZE)
            example_lines = example.splitlines()
            if (len(example_lines) == 1):
                yield f"Example: `{example}`"
            else:
                yield "Example:"
                with self.indent():
                    yield self.TRIPLE_BACKQUOT + 'json'
                    yield from example.splitlines()
                    yield self.TRIPLE_BACKQUOT
                if (not compact):
                    yield
        
        if (not compact):
            if (path_item is not None):
                yield "Generated by Python OpenAPI Parser"
            else:
                yield "Meta:"
                with self.indent():
                    yield " - Generated by Python OpenAPI Parser"
                    if (path_item is not None):
                        yield f" - {item_type.title()} {path_item.pretty_path}"
                        yield f" - Schema {path_item.path}"


__all__ = \
[
    'DescriptionWriter',
]
